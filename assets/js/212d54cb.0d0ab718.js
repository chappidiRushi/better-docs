"use strict";(globalThis.webpackChunkbetter_docs=globalThis.webpackChunkbetter_docs||[]).push([[7482],{8453(e,n,t){t.d(n,{R:()=>c,x:()=>i});var r=t(6540);const s={},o=r.createContext(s);function c(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(o.Provider,{value:n},e.children)}},8831(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"React/performance-and-optimization","title":"Performance And Optimization","description":"----------------","source":"@site/docs/React/Performance And Optimization.md","sourceDirName":"React","slug":"/React/performance-and-optimization","permalink":"/better-docs/docs/React/performance-and-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/React/Performance And Optimization.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"performance-and-optimization","title":"Performance And Optimization","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Advanced State Management","permalink":"/better-docs/docs/React/advanced-state-management"},"next":{"title":"Pattern And Architecture","permalink":"/better-docs/docs/React/pattern-and-architecture"}}');var s=t(4848),o=t(8453);const c={id:"performance-and-optimization",title:"Performance And Optimization",sidebar_position:7},i=void 0,a={},l=[{value:"React.memo",id:"reactmemo",level:2},{value:"useCallback",id:"usecallback",level:2},{value:"useMemo",id:"usememo",level:2},{value:"Performance Best Practices",id:"performance-best-practices",level:2},{value:"Notes &amp; Caveats",id:"notes--caveats",level:2}];function d(e){const n={code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"reactmemo",children:"React.memo"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"React.memo"})," is a HOC that memoizes a component, preventing re-renders if props haven't changed."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Example: React.memo"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React from 'react';\n\nconst Child = React.memo(function Child({ name }) {\n  console.log('Child rendered');\n  return <p>Hello, {name}</p>;\n});\n\nfunction App() {\n  const [count, setCount] = React.useState(0);\n  return (\n    <>\n      <Child name=\"Alice\" />\n      <button onClick={() => setCount(c => c + 1)}>Increment: {count}</button>\n    </>\n  );\n}\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"usecallback",children:"useCallback"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useCallback"})," memoizes a function to prevent unnecessary re-creations on re-renders."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Example: useCallback"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { useState, useCallback } from 'react';\n\nfunction Button({ onClick, label }) {\n  console.log('Button rendered');\n  return <button onClick={onClick}>{label}</button>;\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => setCount(c => c + 1), []);\n\n  return <Button onClick={handleClick} label={`Count: ${count}`} />;\n}\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"usememo",children:"useMemo"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useMemo"})," memoizes a value or calculation to avoid expensive recalculations on every render."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Example: useMemo"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { useState, useMemo } from 'react';\n\nfunction App({ numbers }) {\n  const [multiplier, setMultiplier] = useState(2);\n\n  const doubled = useMemo(() => {\n    console.log('Calculating doubled');\n    return numbers.map(n => n * multiplier);\n  }, [numbers, multiplier]);\n\n  return (\n    <>\n      <p>{doubled.join(', ')}</p>\n      <button onClick={() => setMultiplier(m => m + 1)}>Increase Multiplier</button>\n    </>\n  );\n}\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"performance-best-practices",children:"Performance Best Practices"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Technique"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Memoization (",(0,s.jsx)(n.code,{children:"React.memo"}),", ",(0,s.jsx)(n.code,{children:"useMemo"}),", ",(0,s.jsx)(n.code,{children:"useCallback"}),")"]}),(0,s.jsx)(n.td,{children:"Prevent unnecessary re-renders or recalculations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Splitting Components"}),(0,s.jsx)(n.td,{children:"Smaller components re-render independently"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Avoid Inline Functions/Objects"}),(0,s.jsx)(n.td,{children:"Inline values create new references on each render"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Lazy Loading"}),(0,s.jsxs)(n.td,{children:["Load components or modules only when needed (",(0,s.jsx)(n.code,{children:"React.lazy"}),", ",(0,s.jsx)(n.code,{children:"Suspense"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Key Prop for Lists"}),(0,s.jsx)(n.td,{children:"Proper keys prevent re-rendering entire lists"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Batching State Updates"}),(0,s.jsx)(n.td,{children:"Group multiple state changes to reduce renders"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Avoid Heavy Calculations in Render"}),(0,s.jsx)(n.td,{children:"Move to memoized functions or effects"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"notes--caveats",children:"Notes & Caveats"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"React.memo"})," only does shallow comparison of props; for deep objects, consider ",(0,s.jsx)(n.code,{children:"useMemo"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Overusing memoization can increase complexity; profile before optimization."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useCallback"})," and ",(0,s.jsx)(n.code,{children:"useMemo"})," are only beneficial when their dependencies are stable and recalculation is expensive."]}),"\n",(0,s.jsx)(n.li,{children:"Lazy load routes and components to reduce init"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);