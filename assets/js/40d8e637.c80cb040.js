"use strict";(globalThis.webpackChunkbetter_docs=globalThis.webpackChunkbetter_docs||[]).push([[4812],{7061(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Typescript/Type-System-Core","title":"Type System Core","description":"Fundamental concepts that define how TypeScript types are declared, inferred, and enforced","source":"@site/docs/Typescript/Type System Core.md","sourceDirName":"Typescript","slug":"/Typescript/Type-System-Core","permalink":"/better-docs/docs/Typescript/Type-System-Core","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Typescript/Type System Core.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"Type-System-Core","title":"Type System Core","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Tooling & Ecosystem","permalink":"/better-docs/docs/Typescript/tooling-ecosystem"},"next":{"title":"Objects & Functions","permalink":"/better-docs/docs/Typescript/objects-functions"}}');var s=t(4848),i=t(8453);const o={id:"Type-System-Core",title:"Type System Core",sidebar_position:3},a="Type System Core",l={},c=[{value:"Type Annotations",id:"type-annotations",level:2},{value:"Type Inference",id:"type-inference",level:2},{value:"Structural Typing",id:"structural-typing",level:2},{value:"any, unknown",id:"any-unknown",level:2},{value:"void, never",id:"void-never",level:2},{value:"Type Assertions",id:"type-assertions",level:2},{value:"Notes",id:"notes",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"type-system-core",children:"Type System Core"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Fundamental concepts that define how TypeScript types are declared, inferred, and enforced"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"type-annotations",children:"Type Annotations"}),"\n",(0,s.jsx)(n.p,{children:"Explicit syntax used to declare the type of variables, parameters, return values, and object shapes."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Examples"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// variable annotations\nlet count: number = 1;                      // number\nlet title: string = 'TS';                   // string\nlet active: boolean = true;                 // boolean\n\n// function annotations\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// object shape annotations\nlet user: { id: number; name: string } = {\n  id: 1,\n  name: 'Dev'\n};\n\n// array annotations\nlet list: number[] = [1, 2, 3];             // number[] | Array<number>\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"type-inference",children:"Type Inference"}),"\n",(0,s.jsx)(n.p,{children:"Automatic deduction of types by the compiler based on assigned values and usage."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Examples"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"let count = 1;                              // inferred as number\nlet title = 'TS';                           // inferred as string\nlet active = true;                          // inferred as boolean\n\n// function return type inference\nfunction multiply(a: number, b: number) {\n  return a * b;                             // inferred return type: number\n}\n\n// contextual typing\nconst handler = (event: MouseEvent) => {\n  event.preventDefault();                   // event inferred from context\n};\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"structural-typing",children:"Structural Typing"}),"\n",(0,s.jsx)(n.p,{children:"Type compatibility based on object shape rather than explicit declarations or inheritance."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Examples"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type A = { id: number };\ntype B = { id: number; name: string };\n\nlet a: A;\nlet b: B = { id: 1, name: 'Dev' };\n\na = b;                                      // allowed (structure compatible)\n// b = a;                                   // \u274c missing property 'name'\n\n// function parameter compatibility\nfunction logId(value: { id: number }) {}\nlogId({ id: 1, extra: true });              // allowed\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"any-unknown",children:"any, unknown"}),"\n",(0,s.jsxs)(n.p,{children:["Top types that disable strict type checking (",(0,s.jsx)(n.code,{children:"any"}),") or require explicit narrowing (",(0,s.jsx)(n.code,{children:"unknown"}),")."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Examples"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"let a: any = 1;                             // any\nlet u: unknown = 1;                         // unknown\n\n// any allows unsafe operations\na.toUpperCase();                            // allowed\n\n// unknown requires narrowing\nif (typeof u === 'string') {\n  u.toUpperCase();                          // safe after check\n}\n\n// assignment behavior\nlet str1: string = a;                       // allowed\n// let str2: string = u;                    // \u274c not allowed\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"void-never",children:"void, never"}),"\n",(0,s.jsx)(n.p,{children:"Special return types representing absence of a value or unreachable code paths."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Examples"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// void: no meaningful return value\nfunction log(message: string): void {\n  console.log(message);\n}\n\nlet v: void = undefined;                    // void\n\n// never: function never completes\nfunction fail(error: string): never {\n  throw new Error(error);\n}\n\nfunction infinite(): never {\n  while (true) {}\n}\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"type-assertions",children:"Type Assertions"}),"\n",(0,s.jsx)(n.p,{children:"Compile-time hints that tell the compiler to treat a value as a specific type."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Examples"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"let value: unknown = 'text';\n\n// angle-bracket syntax\nlet len1: number = (<string>value).length; // assertion\n\n// as-syntax (recommended)\nlet len2: number = (value as string).length; // assertion\n\n// DOM assertions\nconst input = document.querySelector('input') as HTMLInputElement;\ninput.value = 'hello';\n"})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type inference reduces the need for explicit annotations"}),"\n",(0,s.jsx)(n.li,{children:"Structural typing enables flexible object compatibility"}),"\n",(0,s.jsxs)(n.li,{children:["Prefer ",(0,s.jsx)(n.code,{children:"unknown"})," over ",(0,s.jsx)(n.code,{children:"any"})," for safer type handling"]}),"\n",(0,s.jsx)(n.li,{children:"Type assertions do not perform runtime checks"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);