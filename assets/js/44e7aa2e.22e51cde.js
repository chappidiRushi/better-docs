"use strict";(globalThis.webpackChunkbetter_docs=globalThis.webpackChunkbetter_docs||[]).push([[6042],{4545(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Typescript/Advanced-Meta_Types","title":"Advanced & Meta Types","description":"TypeScript type-level constructs for transforming, deriving, and validating types","source":"@site/docs/Typescript/Meta Types.md","sourceDirName":"Typescript","slug":"/Typescript/Advanced-Meta_Types","permalink":"/better-docs/docs/Typescript/Advanced-Meta_Types","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Typescript/Meta Types.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Advanced & Meta Types","id":"Advanced-Meta_Types","sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Generics","permalink":"/better-docs/docs/Typescript/Generics"},"next":{"title":"Utility & Standard Types","permalink":"/better-docs/docs/Typescript/utility-standard_types"}}');var r=s(4848),i=s(8453);const a={title:"Advanced & Meta Types",id:"Advanced-Meta_Types",sidebar_position:9},d="Advanced & Meta Types",l={},o=[{value:"keyof",id:"keyof",level:2},{value:"typeof",id:"typeof",level:2},{value:"Indexed Access Types",id:"indexed-access-types",level:2},{value:"Conditional Types",id:"conditional-types",level:2},{value:"infer Keyword",id:"infer-keyword",level:2},{value:"Mapped Types",id:"mapped-types",level:2},{value:"Template Literal Types",id:"template-literal-types",level:2},{value:"Recursive Types",id:"recursive-types",level:2},{value:"satisfies Operator",id:"satisfies-operator",level:2},{value:"Notes",id:"notes",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"advanced--meta-types",children:"Advanced & Meta Types"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"TypeScript type-level constructs for transforming, deriving, and validating types"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"keyof",children:"keyof"}),"\n",(0,r.jsx)(n.p,{children:"Produces a union of property names from a given type."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type User = {\n  id: number;\n  name: string;\n};\n\ntype UserKeys = keyof User;      // 'id' | 'name'\n\nfunction get<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"typeof",children:"typeof"}),"\n",(0,r.jsx)(n.p,{children:"Extracts the type of a value or variable."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const config = {\n  env: 'prod',\n  debug: false\n};\n\ntype Config = typeof config;     // { env: string; debug: boolean }\n\nfunction init(options: typeof config) {}\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"indexed-access-types",children:"Indexed Access Types"}),"\n",(0,r.jsx)(n.p,{children:"Accesses the type of a specific property using indexing syntax."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type User = {\n  id: number;\n  profile: {\n    name: string;\n  };\n};\n\ntype IdType = User['id'];         // number\ntype NameType = User['profile']['name']; // string\n\ntype Value<T, K extends keyof T> = T[K];\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"conditional-types",children:"Conditional Types"}),"\n",(0,r.jsx)(n.p,{children:"Selects a type based on a compile-time condition."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>;        // true\ntype B = IsString<number>;        // false\n\n// conditional distribution over unions\ntype ToArray<T> = T extends any ? T[] : never;\ntype U = ToArray<string | number>; // string[] | number[]\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"infer-keyword",children:"infer Keyword"}),"\n",(0,r.jsx)(n.p,{children:"Introduces a type variable to capture part of a type in a conditional type."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type ReturnTypeOf<T> = T extends (...args: any[]) => infer R\n  ? R\n  : never;\n\nfunction fn() {\n  return 10;\n}\n\ntype Result = ReturnTypeOf<typeof fn>; // number\n\n// infer with generics\ntype Unwrap<T> = T extends Promise<infer U> ? U : T;\n\ntype A = Unwrap<Promise<string>>; // string\ntype B = Unwrap<number>;          // number\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"mapped-types",children:"Mapped Types"}),"\n",(0,r.jsx)(n.p,{children:"Creates new types by transforming properties of existing types."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type User = {\n  id: number;\n  name: string;\n};\n\n// built-in mapped types\ntype ReadonlyUser = Readonly<User>;\ntype PartialUser = Partial<User>;\n\n// custom mapped type\ntype Nullable<T> = {\n  [K in keyof T]: T[K] | null;\n};\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"template-literal-types",children:"Template Literal Types"}),"\n",(0,r.jsx)(n.p,{children:"Constructs string literal types using template string syntax."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Event = 'click' | 'focus';\n\ntype HandlerName = `on${Capitalize<Event>}`;\n// 'onClick' | 'onFocus'\n\nfunction handle(event: HandlerName) {}\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"recursive-types",children:"Recursive Types"}),"\n",(0,r.jsx)(n.p,{children:"Types that reference themselves to model nested or tree-like structures."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type TreeNode<T> = {\n  value: T;\n  children?: TreeNode<T>[];\n};\n\nconst tree: TreeNode<number> = {\n  value: 1,\n  children: [{ value: 2 }]\n};\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"satisfies-operator",children:"satisfies Operator"}),"\n",(0,r.jsx)(n.p,{children:"Validates that a value conforms to a type without changing its inferred type."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)("summary",{children:"Examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Config = {\n  mode: 'dev' | 'prod';\n  debug: boolean;\n};\n\nconst config = {\n  mode: 'dev',\n  debug: true\n} satisfies Config;\n\n// retains literal types\nconfig.mode;                      // 'dev'\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Meta types operate purely at compile time"}),"\n",(0,r.jsx)(n.li,{children:"Conditional types enable powerful type logic"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"infer"})," extracts sub-types from complex types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"satisfies"})," validates shape without widening"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,n,s){s.d(n,{R:()=>a,x:()=>d});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);