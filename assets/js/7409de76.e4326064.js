"use strict";(globalThis.webpackChunkbetter_docs=globalThis.webpackChunkbetter_docs||[]).push([[8981],{1275(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"mongo/mongoose-aggregation","title":"Mongoose Aggregation","description":"-----------------","source":"@site/docs/mongo/Mongoose Aggregation.md","sourceDirName":"mongo","slug":"/mongo/mongoose-aggregation","permalink":"/better-docs/docs/mongo/mongoose-aggregation","draft":false,"unlisted":false,"editUrl":"https://github.com/chappidirushi/better-docs/tree/main/docs/mongo/Mongoose Aggregation.md","tags":[],"version":"current","sidebarPosition":32,"frontMatter":{"id":"mongoose-aggregation","title":"Mongoose Aggregation","sidebar_position":32},"sidebar":"tutorialSidebar","previous":{"title":"Mongoose Population System","permalink":"/better-docs/docs/mongo/mongoose-population"}}');var o=s(4848),t=s(8453);const i={id:"mongoose-aggregation",title:"Mongoose Aggregation",sidebar_position:32},a=void 0,l={},c=[{value:"Aggregation Wrapper",id:"aggregation-wrapper",level:2},{value:"Pipeline Casting",id:"pipeline-casting",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Streaming Aggregations",id:"streaming-aggregations",level:2},{value:"Notes",id:"notes",level:2},{value:"Caveats",id:"caveats",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"aggregation-wrapper",children:"Aggregation Wrapper"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"How Mongoose exposes MongoDB aggregation pipelines"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Interview points"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Model.aggregate()"})," returns an Aggregation object"]}),"\n",(0,o.jsx)(n.li,{children:"Mostly pass-through to MongoDB"}),"\n",(0,o.jsx)(n.li,{children:"Adds minimal abstraction (casting, middleware)"}),"\n"]}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsx)("summary",{children:"Examples (Node.js)"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Basic aggregation\nconst result = await Order.aggregate([\n  { $match: { status: 'paid' } },\n  { $group: { _id: '$userId', total: { $sum: '$amount' } } }\n]);\n\n// Aggregation object (lazy)\nconst agg = Order.aggregate();\nagg.match({ status: 'paid' });\nagg.group({ _id: '$userId', total: { $sum: '$amount' } });\n\nawait agg.exec(); // execution\n"})})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"pipeline-casting",children:"Pipeline Casting"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Automatic casting of pipeline values using schema metadata"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Interview points"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Only applies to ",(0,o.jsx)(n.code,{children:"$match"})]}),"\n",(0,o.jsx)(n.li,{children:"Driven by SchemaTypes"}),"\n",(0,o.jsx)(n.li,{children:"Can be disabled"}),"\n"]}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsx)("summary",{children:"Examples (Node.js)"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Schema\nconst schema = new Schema({\n  userId: Schema.Types.ObjectId,\n  createdAt: Date,\n  amount: Number\n});\n\n// String \u2192 ObjectId cast\nawait Order.aggregate([\n  { $match: { userId: '64f0c1...' } }\n]);\n\n// String \u2192 Date cast\nawait Order.aggregate([\n  { $match: { createdAt: '2024-01-01' } }\n]);\n\n// Disable casting\nOrder.aggregate([{ $match: { amount: '100' } }]).option({ cast: false });\n"})})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Cost model and optimization constraints"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Interview points"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Runs entirely on MongoDB server"}),"\n",(0,o.jsx)(n.li,{children:"Bypasses Mongoose middleware (mostly)"}),"\n",(0,o.jsxs)(n.li,{children:["Memory limits apply (100MB unless ",(0,o.jsx)(n.code,{children:"allowDiskUse"}),")"]}),"\n"]}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsx)("summary",{children:"Examples (Node.js)"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Allow disk use\nawait Order.aggregate([\n  { $sort: { createdAt: -1 } },\n  { $group: { _id: '$userId', total: { $sum: '$amount' } } }\n]).option({ allowDiskUse: true });\n\n// Index-aware $match should come early\nawait Order.aggregate([\n  { $match: { status: 'paid' } }, // uses index\n  { $project: { userId: 1, amount: 1 } }\n]);\n"})})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"streaming-aggregations",children:"Streaming Aggregations"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Processing aggregation results incrementally"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Interview points"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Uses MongoDB cursors"}),"\n",(0,o.jsx)(n.li,{children:"Prevents loading full result set into memory"}),"\n",(0,o.jsx)(n.li,{children:"Useful for large pipelines"}),"\n"]}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsx)("summary",{children:"Examples (Node.js)"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Cursor-based aggregation\nconst cursor = Order.aggregate([\n  { $match: { status: 'paid' } },\n  { $group: { _id: '$userId', total: { $sum: '$amount' } } }\n]).cursor({ batchSize: 100 }).exec();\n\nfor await (const doc of cursor) {\n  process(doc);\n}\n\n// Stream API\nOrder.aggregate([...]).cursor().on('data', doc => {\n  handle(doc);\n});\n"})})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Aggregation results are plain JS objects"}),"\n",(0,o.jsx)(n.li,{children:"No document middleware or validation"}),"\n",(0,o.jsx)(n.li,{children:"Preferred for analytics and reporting"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"caveats",children:"Caveats"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Casting is limited compared to queries"}),"\n",(0,o.jsx)(n.li,{children:"Complex pipelines are harder to debug"}),"\n",(0,o.jsx)(n.li,{children:"Aggregations ignore default projections"}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>i,x:()=>a});var r=s(6540);const o={},t=r.createContext(o);function i(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);