"use strict";(globalThis.webpackChunkbetter_docs=globalThis.webpackChunkbetter_docs||[]).push([[6570],{5111(e,n,o){o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"mongo/mongoose-migrations-schema-evolution","title":"Mongoose Migrations and Schema Evolution","description":"-----------------","source":"@site/docs/mongo/Mongoose Migrations.md","sourceDirName":"mongo","slug":"/mongo/mongoose-migrations-schema-evolution","permalink":"/better-docs/docs/mongo/mongoose-migrations-schema-evolution","draft":false,"unlisted":false,"editUrl":"https://github.com/chappidirushi/better-docs/tree/main/docs/mongo/Mongoose Migrations.md","tags":[],"version":"current","sidebarPosition":42,"frontMatter":{"id":"mongoose-migrations-schema-evolution","title":"Mongoose Migrations and Schema Evolution","sidebar_position":42},"sidebar":"tutorialSidebar","previous":{"title":"Testing and Tooling","permalink":"/better-docs/docs/mongo/mongoose-testing-tooling"},"next":{"title":"Mongoose Plugins and Ecosystem","permalink":"/better-docs/docs/mongo/mongoose-plugins-ecosystem"}}');var i=o(4848),t=o(8453);const a={id:"mongoose-migrations-schema-evolution",title:"Mongoose Migrations and Schema Evolution",sidebar_position:42},r=void 0,c={},d=[{value:"<strong>1. Backward Compatibility</strong>",id:"1-backward-compatibility",level:2},{value:"2. Data Migrations",id:"2-data-migrations",level:2},{value:"3. Versioned Documents",id:"3-versioned-documents",level:2},{value:"4. Deployment Strategies",id:"4-deployment-strategies",level:2},{value:"Notes",id:"notes",level:2},{value:"Caveats",id:"caveats",level:2}];function l(e){const n={blockquote:"blockquote",code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"1-backward-compatibility",children:(0,i.jsx)(n.strong,{children:"1. Backward Compatibility"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Ensure new schema versions can read old documents"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"optional fields | defaults | tolerant readers\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// additive change (safe)\nconst schema = new Schema({\n  email: String,\n  role: { type: String, default: 'user' } // default for old docs\n});\n\n// tolerant read\nfunction normalize(doc) {\n  return {\n    role: doc.role ?? 'user',     // nullish coalescing\n    email: doc.email\n  };\n}\n\n// avoid breaking rename\n// \u274c removing fields before migration\n// \u2705 read old + new during transition\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"2-data-migrations",children:"2. Data Migrations"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"One-time transformations of existing data"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"scripts | batch updates | cursors\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// cursor-based migration\nconst cursor = User.find({ role: { $exists: false } }).cursor({\n  batchSize: 500               // number\n});\n\nfor await (const doc of cursor) {\n  await User.updateOne(\n    { _id: doc._id },\n    { $set: { role: 'user' } } // migration logic\n  );\n}\n\n// bulk migration\nawait User.updateMany(\n  { role: { $exists: false } },\n  { $set: { role: 'user' } }\n);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-versioned-documents",children:"3. Versioned Documents"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Track document shape explicitly inside the document"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"schemaVersion | __v (custom)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const schema = new Schema({\n  schemaVersion: {\n    type: Number,\n    required: true,\n    default: 1              // number\n  },\n  email: String\n});\n\nfunction upgrade(doc) {\n  if (doc.schemaVersion === 1) {\n    doc.schemaVersion = 2;\n    doc.role = 'user';\n  }\n  return doc;\n}\n\n// lazy migration on read\nconst doc = await User.findById(id);\nupgrade(doc);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"4-deployment-strategies",children:"4. Deployment Strategies"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Rollout schema and data changes without downtime"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"expand \u2192 migrate \u2192 contract\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// 1. expand\n// deploy code that supports old + new fields\n\n// 2. migrate\nawait User.updateMany(\n  { schemaVersion: 1 },\n  { $set: { schemaVersion: 2 } }\n);\n\n// 3. contract\n// remove legacy fields + code paths in later deploy\n\n// index changes via separate migration\nawait User.collection.createIndex(\n  { email: 1 },\n  { unique: true, background: true }\n);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prefer additive changes over breaking ones"}),"\n",(0,i.jsx)(n.li,{children:"Data migrations should be idempotent"}),"\n",(0,i.jsx)(n.li,{children:"Lazy migrations reduce operational risk"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"caveats",children:"Caveats"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Large migrations must be throttled"}),"\n",(0,i.jsx)(n.li,{children:"Rollbacks are hard without versioned data"}),"\n",(0,i.jsx)(n.li,{children:"Schema changes and index changes are separate concerns"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453(e,n,o){o.d(n,{R:()=>a,x:()=>r});var s=o(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);