"use strict";(globalThis.webpackChunkbetter_docs=globalThis.webpackChunkbetter_docs||[]).push([[5811],{3565(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"typescript/glossary","title":"Glossary","description":"---","source":"@site/docs/typescript/Glossary.md","sourceDirName":"typescript","slug":"/typescript/glossary","permalink":"/better-docs/docs/typescript/glossary","draft":false,"unlisted":false,"editUrl":"https://github.com/chappidirushi/better-docs/tree/main/docs/typescript/Glossary.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"glossary","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Typescript","permalink":"/better-docs/docs/typescript/"},"next":{"title":"Language & Compiler Basics","permalink":"/better-docs/docs/typescript/language-compiler-basics"}}');var i=s(4848),t=s(8453);const l={id:"glossary",sidebar_position:1},c="Glossary",o={},d=[{value:"A",id:"a",level:2},{value:"B",id:"b",level:2},{value:"C",id:"c",level:2},{value:"D",id:"d",level:2},{value:"E",id:"e",level:2},{value:"F",id:"f",level:2},{value:"G",id:"g",level:2},{value:"I",id:"i",level:2},{value:"J",id:"j",level:2},{value:"K",id:"k",level:2},{value:"L",id:"l",level:2},{value:"M",id:"m",level:2},{value:"N",id:"n",level:2},{value:"O",id:"o",level:2},{value:"P",id:"p",level:2},{value:"R",id:"r",level:2},{value:"S",id:"s",level:2},{value:"T",id:"t",level:2},{value:"U",id:"u",level:2},{value:"V",id:"v",level:2},{value:"W",id:"w",level:2},{value:"Z",id:"z",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"glossary",children:"Glossary"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"a",children:"A"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Abstract Class"})," \u2014 A class that cannot be instantiated and is intended to be extended."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access Modifier"})," \u2014 Keyword controlling visibility (",(0,i.jsx)(n.code,{children:"public"}),", ",(0,i.jsx)(n.code,{children:"protected"}),", ",(0,i.jsx)(n.code,{children:"private"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Ambient Declaration"})," \u2014 A declaration that describes existing variables or modules without implementation."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"any"})," \u2014 A type that disables all type checking."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Assertion Function"})," \u2014 A function that asserts a condition and narrows types using ",(0,i.jsx)(n.code,{children:"asserts"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Awaited<T>"})," \u2014 Utility type that unwraps nested ",(0,i.jsx)(n.code,{children:"Promise"})," types."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"b",children:"B"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"BigInt"})," \u2014 Primitive type for arbitrarily large integers."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Bivariance"})," \u2014 Special variance rule applied to function parameters in callbacks."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"c",children:"C"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Call Signature"})," \u2014 Type definition for a callable object."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Catch Clause Narrowing"})," \u2014 Type narrowing inside ",(0,i.jsx)(n.code,{children:"catch"})," blocks using ",(0,i.jsx)(n.code,{children:"unknown"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Class"})," \u2014 Blueprint for creating objects with properties and methods."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Composite Project"})," \u2014 A TypeScript project configured for project references."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Conditional Type"})," \u2014 A type resolved based on a condition (",(0,i.jsx)(n.code,{children:"T extends U ? X : Y"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Const Assertion (",(0,i.jsx)(n.code,{children:"as const"}),")"]})," \u2014 Prevents literal widening and makes properties readonly."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Control Flow Analysis"})," \u2014 Compiler analysis that narrows types based on code paths."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"d",children:"D"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Declaration File (",(0,i.jsx)(n.code,{children:".d.ts"}),")"]})," \u2014 File that contains only type declarations."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Declaration Merging"})," \u2014 Combining multiple declarations with the same name."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"DefinitelyTyped"})," \u2014 Community repository hosting type definitions."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Discriminated Union"})," \u2014 Union type distinguished by a shared literal property."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Downlevel Iteration"})," \u2014 Compiler support for iterables in older JS targets."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"e",children:"E"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Enum"})," \u2014 A set of named constants (numeric or string-based)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Excess Property Check"})," \u2014 Validation that prevents extra properties on object literals."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Exclude<T, U>"})," \u2014 Removes members of ",(0,i.jsx)(n.code,{children:"U"})," from union ",(0,i.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"f",children:"F"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Function Overload"})," \u2014 Multiple call signatures for a single function implementation."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Function Type"})," \u2014 Type describing parameters and return value of a function."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"g",children:"G"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Generic"})," \u2014 A type parameter that makes components reusable across types."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Generic Constraint"})," \u2014 Restriction applied to a generic type parameter."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Global Scope"})," \u2014 Declarations available everywhere without imports."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"i",children:"I"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"implements"})," \u2014 Keyword enforcing class conformance to an interface."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Index Signature"})," \u2014 Allows arbitrary property keys with a defined value type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Indexed Access Type"})," \u2014 Retrieves property types via indexing (",(0,i.jsx)(n.code,{children:"T[K]"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"infer"})," \u2014 Keyword to infer types within conditional types."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Intersection Type (",(0,i.jsx)(n.code,{children:"&"}),")"]})," \u2014 Combines multiple types into one."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Interface"})," \u2014 Structural contract defining object shape."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Isolated Modules"})," \u2014 Compiler mode ensuring files can be transpiled independently."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"j",children:"J"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"JSDoc Typing"})," \u2014 Using comments to add types in JavaScript files."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"k",children:"K"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"keyof"})," \u2014 Produces a union of property names of a type."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"l",children:"L"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Literal Type"})," \u2014 Type representing a specific value."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"lib"})," \u2014 Compiler option specifying built-in type libraries."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"m",children:"M"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Mapped Type"})," \u2014 Type created by transforming properties of another type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Module"})," \u2014 A file with import/export statements."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Module Resolution"})," \u2014 Strategy for resolving import paths."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"n",children:"N"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Namespace"})," \u2014 Internal module for grouping declarations (legacy)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"never"})," \u2014 Type representing values that never occur."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NonNullable<T>"})," \u2014 Removes ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"undefined"})," from a type."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"o",children:"O"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Object Type Literal"})," \u2014 Inline object type definition."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Optional Property"})," \u2014 Property that may be omitted."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Omit<T, K>"})," \u2014 Removes specified keys from a type."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"p",children:"P"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Partial<T>"})," \u2014 Makes all properties optional."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Path Mapping"})," \u2014 Alias configuration for module imports."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Primitive Type"})," \u2014 Built-in simple types (",(0,i.jsx)(n.code,{children:"string"}),", ",(0,i.jsx)(n.code,{children:"number"}),", ",(0,i.jsx)(n.code,{children:"boolean"}),", etc.)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Project Reference"})," \u2014 Dependency between TypeScript projects."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"r",children:"R"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Readonly<T>"})," \u2014 Makes all properties immutable."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ReadonlyArray<T>"})," \u2014 Immutable array type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Record<K, T>"})," \u2014 Object type with keys ",(0,i.jsx)(n.code,{children:"K"})," and values ",(0,i.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Recursive Type"})," \u2014 Type that references itself."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"s",children:"S"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"satisfies"})," \u2014 Ensures a value conforms to a type without widening."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Source Map"})," \u2014 Maps generated JS back to TS source."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Static Member"})," \u2014 Class member belonging to the class itself."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Strict Mode"})," \u2014 Set of compiler options enabling strict checks."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Structural Typing"})," \u2014 Type compatibility based on shape, not name."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"t",children:"T"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Template Literal Type"})," \u2014 Constructs string types using template syntax."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"this Parameter"})," \u2014 Explicit typing of ",(0,i.jsx)(n.code,{children:"this"})," in functions."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tuple"})," \u2014 Fixed-length array with known element types."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type Alias"})," \u2014 Named type definition."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type Annotation"})," \u2014 Explicit type declaration."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type Assertion"})," \u2014 Forcing the compiler to treat a value as a specific type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type Guard"})," \u2014 Runtime check that narrows a type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type Inference"})," \u2014 Automatic deduction of types by the compiler."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"u",children:"U"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Union Type (",(0,i.jsx)(n.code,{children:"|"}),")"]})," \u2014 Type that can be one of multiple types."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"unknown"})," \u2014 Safe top type requiring narrowing before use."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Utility Type"})," \u2014 Built-in generic helper types."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"v",children:"V"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Variance"})," \u2014 Rules for type assignability in generics."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"void"})," \u2014 Represents absence of a return value."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"w",children:"W"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Widening"})," \u2014 Process of converting literal types to broader types."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"z",children:"Z"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Zero-cost Abstraction"})," \u2014 Type-level features erased at runtime."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453(e,n,s){s.d(n,{R:()=>l,x:()=>c});var r=s(6540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);